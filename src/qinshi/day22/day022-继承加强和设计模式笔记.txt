1. 单元测试：（掌握）
	1. 导入包，Junit4包
		选中项目，右键 => Build Path  => Add Library  => 选中Junit
		选中Junit4  => finish
	2. 写一个单元测试类，命名方式：XxxTest(测试类没有main方法)
		
	3. 在测试类中，设计测试方法，命名方式：testXxx（）
		在方法上方会自动添加一个@Test注解
		
	4. 运行，右键run as JUnit方式
		如果是全部执行，直接选中 @Test注解，右键run as JUnit方式
		如果是某一个方法，直接选中方法名，右键run as JUnit方式
		@Before// 预执行注解，每次执行方法前都会执行该注解
		@After// 每次执行方法后都会执行该注解
	
	5. 运行后结果解释：
		绿条：表示成功执行
		红条：表示执行失败
			1. 代码有异常
			2. 执行失败，逻辑异常

	6. 自己扩展（测试类中的断言assert）
	
2. 工具类：（掌握）
	1. 概念：就是类中只有（静态、非静态）方法，就是为了调用方法。
	2. 作用：就是一个轮子
	3. 分类：
		1. 静态的	
			方法全部都是static修饰的，调用方式：类名.方法名(...);
		
		2. 非静态的	
			通过单例模式获取到对象后。就是只有一个对象的类
			方法全部都是非static修饰的，调用方式：对象名.方法名(...);
			
	4. 工具类命名：
		XxxUtil、XxxUtils、XxxTool、XxxTools

		
3. jar 包	（掌握）
	1. 什么是jar包：就是别人封装好的字节码文件
	2. 作用：就是提高开发效率的。使用轮子
	3. 使用：
		3.1 封装jar包	（造轮子）
			step1：选中自己想要封装成jar包的类，右键export导出
				在输入框中输入 jar:
					1. jar File : 普通的jar包，没有main方法(最常用)  java文件夹下面
						在下面写一个jar包的名字，然后选择生成jar包的路径，finish即可
						
					2. Runnable jar File：可以自己执行的jar包，有main方法		(几乎不用)
						要封装为可以执行的jar包，必须先运行一下当前类。
						然后在下面写一个jar包的名字，然后选择生成jar包的路径，finish即可
				
				在cmd控制台中，切换路径到jar文件所在的目录。
				输入 ：java -jar jar包名.jar
				
			step2：剩下的就是按照 3.1中的步骤使用即可
		3.2 使用jar包（掌握）
			step1：在当前项目下，创建一文件夹folder，叫lib
			step2：将jar包复制到当前的lib文件夹中
			step3：将所有的jar包选中右键，build path
				add library
			step4：在我们代码中通过创建对象或者类名的方式使用即可
			
		注意：
			红色感叹号产生原因：项目中使用到的jar包跟，当前项目中 存在的jar包版本不一致导致的
			红色感叹号解决方案：如果可以知道是哪一个jar包造成的， 就直接将该jar直接remove，
				重新导入新的jar包。
				如果不知道是哪一个jar包造成的，就全部移除，全部重新导入。
			
4. 	Properties资源（配置）文件的解析（重点）
---------------------------------（注意：重点）-------------------------------------
	以后配置文件都要放到项目中的一个或者几个单独的文件夹中，为了好管理。
	该文件夹类型是source folder类型，源文件夹，eclipse工具会自动编译
---------------------------------------------------------------------------------
		
	传统方式获取流是new创建的，而在web开发中有可能获取不到配置文件，为了避免这种情况，用以下方式获取流：
 
 	1. 通过当前类字节码文件的方式，一般是用当前类的字节码文件
 		当前类.class.getResourceAsStream("/文件路径/文件名");
 		/:如果是resource文件夹，直接写文件名，如果是普通文件夹写文件夹名/文件名
 		/还是需要
 		
 	2. 通过类加载器的方式 
 		1.同当前类的加载器获取
 			1.当前类.class.getClassLoader();//获取当前类加载器
 			2.classLoader.getResourceAsStream("文件路径/文件名");//通过类加载器获取流对象,如果是源文件夹，直接文件名
 
 		2.通过当前线程的类加载器获取流
 			1、ClassLoader classLoader = Thread.currentThread().getContextClassLoader();	//获取当前线程类加载器
			2、InputStream is = classLoader.getResourceAsStream("文件路径/文件名");//通过当前线程的类加载器获取流对象,如果是源文件夹，直接文件名
			
		建议用当前线程类的加载器方式获取流，线程安全问题
		
		类加载器：（ 扩展，5个月后会讲）
			加载字节码的一个类而已：
				1. 启动类加载器(Bootstrap classLoader) c++
					本地代码实现的类加载器，它负责将 <JAVA_HOME>/lib下面的核心类库 
					或 -Xbootclasspath选项指定的jar包等 虚拟机识别的类库 加载到内存中。
					由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，
					所以 不允许直接通过引用进行操作。
					
				2. 拓展类加载器(Extension classLoader):
					扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）
					实现的，它负责将 <JAVA_HOME >/lib/ext或者由系统变量-Djava.ext.dir指定位置
					中的类库 加载到内存中。开发者可以直接使用标准扩展类加载器。
				
				3. 系统类 （应用类）加载器(Application classLoader): 
					系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的，
					它负责将 用户类路径(java -classpath或-Djava.class.path变量所指的目录，
					即当前类所在路径及其引用的第三方类库的路径，如第四节中的问题6所述)下的类库 加载到内存中。
					开发者可以直接使用系统类加载器。
	
5. 设计模式：(框架中使用，是程序设计的高级思想) 
	1. 单例模式：（重点）
 *		1. 概念：设计一个类，这个类只能创建一个对象。（限制创建对象对象数量）
 *
 *		2. 怎么设计？
 *			控制创建对象的数量 => 创建对象通过new 调用构造方法 => 控制构造方法就能控制创建对象
 *			控制调用构造方法  => 用private修饰  => 需要给外部提供一个对象  =>
 *			先在类中创建一个对象 （联想到封装） => 提供一个公共的  getInstance给外部返回一个对象
 *		
 *		3. 步骤：
 *			1. 私有化构造方法
 *			2. 在类中创建一个对象，并且用private、static、final修饰
 *					private为了避免在外部直接访问当前对象
 *					static是为了在静态方法中可以返回当前类中的对象
 *					final：可加可不加，加了可以保证不可修改，且提供获取效率
 *
 *			3. 提供一个public修饰的方法getInstance给外部返回一个对象
 *
 *		4. 单例模式获取方式：
 *			1. 饿汉模式：预加载模式	（优化方式：静态内部类）
 *				优点：在类加载的时候，就创建好对象放到静态区了，获取对象效率高。线程安全
 *				缺点：类加载效率低，并且static修饰的成员占用资源。
 *
 *			2. 懒汉模式：懒加载模式	(优化方式：双重校验锁)
 *				优点：节省资源，在需要的时候创建对象。
 *				缺点：线程不安全。获取对象的时候，效率低
 *				最简单的线程安全的方式：同步方法，效率低
 *				更好的的线程安全的方式：双重校验锁
 *					
 *			3. 枚举：
 *				public enum Singleton{
					INSTANCE;
				}			
 *
 *		5. 作用：
 *				1. 全局配置文件 
 *				2. 全局日志文件 
 *				3. 节省资源，例如，回收站、资源管理器、游戏单开窗口
 *
 *		6. 使用选择：
 *				一般用饿汉模式，如果有序列化（自己百度扩展）要求，用枚举。
 *
 *		7. 不需要频繁创建对象的时候；不允许多个对象 用单例
 
	2. 装饰者模式：（了解）
		命名方式：XxxDecorator
 * 		装饰者模式指的是在不必改变原类（Input）文件和使用继承的情况下，动态地扩展一个类的功能。
 * 			它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
 * 
 * 			实现步骤 ：通过对原类文件继承，对原有方法功能的基础上，增强新的功能
 * 
 * 		使用场景：
 * 			不必改变原类，并且对原有功能进行加强的时候，就需要用装饰者模式
 
	3. 适配器模式：（了解）
		适配器类：
 *		命名方式： XxxXxxAdaptor
 *	
 *		解决了两个功能的协同工作。（苹果充电器和华为手机充电的问题）
 *		扩展性强，成本低廉
 *
 *		使用场景：
 			不同的类需要配合完成功能
	
	4. 简单工厂模式：（了解）Spring框架中有用到
		简单工厂模式：（后面可以用反射优化代码）
 *		优点：
 *			1.将生产和消费分离（解耦），即创建对象和使用对象的功能分离，便于管理
 *		缺点：
 *			1.扩展性弱，如果添加了新的产品，则需要修改工厂方法
 *
 *		使用场景：
 *			适用于产品数量较少，且不经常改变的情况
 
	
6. ThreadLocal类	（掌握简单使用）：
	 解决了线程安全问题，通过线程隔离有安全问题的数据实现的，底层是通过map保存线程id和值的。
	
	
	
	
	
		